// "type" and "void" classes are defined directly by compiler.

#[no_builtin]
module core.builtin;

#[builtin]
extern def sizeof(t: type) onlymeta: int32 = "__builtin_sizeof";

#[builtin]
extern def stringof!(T)(ref p: T): 'static raw_ptr!(uint8) = "__builtin_stringof";

#[builtin]
extern def 'a address_of!(T)('a ref :T): 'a raw_ptr!(val(T)) = "__builtin_make_ptr_from_ref";

// TODO: move to else where
extern def malloc(val :int32): 'unmanaged untyped_raw_ptr = "rill_core_malloc";
extern def 'a free(val :'a untyped_raw_ptr): void = "rill_core_free";
extern def free!(T)(val :raw_ptr!(T)): void = "rill_core_free";

// TODO: fix
extern def memcpy(val :raw_ptr!(uint8), val :raw_ptr!(uint8), :int32): void = "rill_core_memcpy";
extern def memset(val :raw_ptr!(uint8), val :uint8, val :int32): void = "rill_core_memset";

#[builtin]
extern def 'a unsafe_ptr_cast!(T)(val :'a untyped_raw_ptr): 'a raw_ptr!(T) = "__builtin_unsafe_ptr_cast";

def new!(T)() {
    val p = malloc(sizeof!(T)());
    return p;
}

//
#[builtin]
extern def 'a operator unary& ('a ref :int32): 'a raw_ptr!(int32) = "__builtin_make_ptr_from_ref";


//def to!(T)(v: int32) when T

// bool
#[builtin, primitive, size = 1u, align = 1u]
extern class bool = "__builtin_bool_type"
#[builtin]
extern def operator unary! (val :bool): bool = "__builtin_op_unary_pre_!_bool";

// uint8
#[builtin, primitive, size = 1u, align = 1u]
extern class uint8 = "__builtin_uint8_type"

// int32
#[builtin, primitive, size = 4u, align = 4u]
extern class int32 = "__builtin_int32_type"

// TODO: implement attributes scope
#[builtin]
extern def operator+(val :int32, val :int32): int32 = "__builtin_op_binary_+_int_int";
#[builtin]
extern def operator-(val :int32, val :int32): int32 = "__builtin_op_binary_-_int_int";
#[builtin]
extern def operator*(val :int32, val :int32): int32 = "__builtin_op_binary_*_int_int";
#[builtin]
extern def operator/(val :int32, val :int32): int32 = "__builtin_op_binary_/_int_int";
#[builtin]
extern def operator%(val :int32, val :int32): int32 = "__builtin_op_binary_%_int_int";
#[builtin]
extern def operator<(val :int32, val :int32): bool = "__builtin_op_binary_<_int_int";
#[builtin]
extern def operator>(val :int32, val :int32): bool = "__builtin_op_binary_>_int_int";
#[builtin]
extern def operator|(val :int32, val :int32): int32 = "__builtin_op_binary_|_int_int";
#[builtin]
extern def operator^(val :int32, val :int32): int32 = "__builtin_op_binary_^_int_int";
#[builtin]
extern def operator&(val :int32, val :int32): int32 = "__builtin_op_binary_&_int_int";
#[builtin]
extern def operator>=(val :int32, val :int32): bool = "__builtin_op_binary_>=_int_int";
#[builtin]
extern def operator<=(val :int32, val :int32): bool = "__builtin_op_binary_<=_int_int";
#[builtin]
extern def operator<<(val :int32, val :int32): int32 = "__builtin_op_binary_<<_int_int";
#[builtin]
extern def operator>>>(val :int32, val :int32): int32 = "__builtin_op_binary_>>>_int_int";
#[builtin]
extern def operator>>(val :int32, val :int32): int32 = "__builtin_op_binary_>>_int_int";
#[builtin]
extern def operator==(val :int32, val :int32): bool = "__builtin_op_binary_==_int_int";
#[builtin]
extern def operator!=(val :int32, val :int32): bool = "__builtin_op_binary_!=_int_int";
#[force_inline]
def operator pre++(ref mutable i: int32): void
{
    i = i + 1;
    return;
}
#[force_inline]
def operator pre--(ref mutable i:int32): void
{
    i = i - 1;
    return;
}


// uint32
#[builtin, primitive, size = 4u, align = 4u]
extern class uint32 = "__builtin_uint32_type"

// TODO: implement attributes scope
#[builtin]
extern def operator+(val :uint32, val :uint32): uint32 = "__builtin_op_binary_+_uint_uint";
#[builtin]
extern def operator-(val :uint32, val :uint32): uint32 = "__builtin_op_binary_-_uint_uint";
#[builtin]
extern def operator*(val :uint32, val :uint32): uint32 = "__builtin_op_binary_*_uint_uint";
#[builtin]
extern def operator/(val :uint32, val :uint32): uint32 = "__builtin_op_binary_/_uint_uint";
#[builtin]
extern def operator%(val :uint32, val :uint32): uint32 = "__builtin_op_binary_%_uint_uint";
#[builtin]
extern def operator<(val :uint32, val :uint32): bool = "__builtin_op_binary_<_uint_uint";
#[builtin]
extern def operator>(val :uint32, val :uint32): bool = "__builtin_op_binary_>_uint_uint";
#[builtin]
extern def operator|(val :uint32, val :uint32): uint32 = "__builtin_op_binary_|_uint_uint";
#[builtin]
extern def operator^(val :uint32, val :uint32): uint32 = "__builtin_op_binary_^_uint_uint";
#[builtin]
extern def operator&(val :uint32, val :uint32): uint32 = "__builtin_op_binary_&_uint_uint";
#[builtin]
extern def operator>=(val :uint32, val :uint32): bool = "__builtin_op_binary_>=_uint_uint";
#[builtin]
extern def operator<=(val :uint32, val :uint32): bool = "__builtin_op_binary_<=_uint_uint";
#[builtin]
extern def operator<<(val :uint32, val :uint32): uint32 = "__builtin_op_binary_<<_uint_uint";
#[builtin]
extern def operator>>(val :uint32, val :uint32): uint32 = "__builtin_op_binary_>>_uint_uint";
#[builtin]
extern def operator>>>(val :uint32, val :uint32): uint32 = "__builtin_op_binary_>>>_uint_uint";
#[builtin]
extern def operator==(val :uint32, val :uint32): bool = "__builtin_op_binary_==_uint_uint";
#[builtin]
extern def operator!=(val :uint32, val :uint32): bool = "__builtin_op_binary_!=_uint_uint";
#[force_inline]
def operator pre++(ref mutable i: uint32): void
{
    i = i + 1u;
}
#[force_inline]
def operator pre--(ref mutable i: uint32): void
{
    i = i - 1u;
}

// array
#[builtin, array_type]
extern class array!(T, N: uint32) = "__builtin_array_type"
#[builtin]
extern def 'a operator unary& !(T, N: uint32)('a ref _v:array!(T, N)): 'a raw_ptr!T = "__builtin_take_address_from_array";
#[force_inline]
def 'a operator[] !(T, N: uint32)('a ref arr :array!(T, N), index: int32): 'a ref(T) => *(&arr + index);
// uint version. TODO: remove
#[force_inline]
def 'a operator[] !(T, N: uint32)('a ref arr :array!(T, N), index: uint32): 'a ref(T) => *(&arr + index);


// untyped raw pointer
#[builtin, primitive, ptr_constraints, size = 8u, align = 8u]
extern class 'a untyped_raw_ptr = "__builtin_untyped_raw_ptr_type"

// raw pointer
#[builtin, primitive, ptr_constraints, size = 8u, align = 8u]
extern class 'a raw_ptr!(T) = "__builtin_raw_ptr_type"
//
// ('p: 'a) ctor=(rhs: 'p raw_ptr)
//
// ('p: 'r1, 'r1, 'r2) op=('r1 ref: 'p raw_ptr, 'r2 ref: 'p raw_ptr): 'r1 ref('p raw_ptr)
// NOT: ('p: 'a) op=(: 'a raw_ptr, : 'p raw_ptr): ref('a raw_ptr)
//


#[builtin]
extern def 'a operator+ !(T)(val :'a raw_ptr!(T), val :int32): 'a raw_ptr!(T) = "__builtin_op_binary_+_raw_ptr_int";
#[force_inline]
def operator- !(T)(p :raw_ptr!(T), n :int32): raw_ptr!(T) {
    return p + (0 - n);
}

// uint version. TODO: remove
#[builtin]
extern def 'a operator+ !(T)(val :'a raw_ptr!(T), val :uint32): 'a raw_ptr!(T) = "__builtin_op_binary_+_raw_ptr_int";
#[force_inline]
def operator- !(T)(p :raw_ptr!(T), n :uint32): raw_ptr!(T) => p + (0u - n);

#[builtin]
extern def 'a operator unary* !(T)(val :'a raw_ptr!(T)): 'a ref(T) = "__builtin_op_unary_pre_*_raw_ptr";
#[force_inline]
def 'a operator[] !(T)(p :'a raw_ptr!(T), index: int32): 'a ref(T) => *(p+index);
// uint version. TODO: remove
#[force_inline]
def operator[] !(T)(p :raw_ptr!(T), index: uint32): ref(T) => *(p+index);
